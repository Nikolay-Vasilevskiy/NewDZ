//Задача 73: Есть число N. Сколько групп M, можно получить при разбиении всех
//чисел на группы, так чтобы в одной группе все числа были взаимно просты (все
//числа в группе друг на друга не делятся)? Найдите M при заданном N и получите
//одно из разбиений на группы N ≤ 10²⁰.
//Например, для N = 50, M получается 6
//- Группа 1: 1
//- Группа 2: 2 3 11 13 17 19 23 29 31 37 41 43 47
//- Группа 3: 4 6 9 10 14 15 21 22 25 26 33 34 35 38 39 46 49
//- Группа 4: 8 12 18 20 27 28 30 42 44 45 50
//- Группа 5: 7 16 24 36 40
//- Группа 6: 5 32 48

//Другой пример разбиения на группы с тем же N:
//- Группа 1: 1
//- Группа 2: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47
//- Группа 3: 4 6 9 10 14 15 21 22 25 26 33 34 35 38 39 46 49
//- Группа 4: 8 12 18 20 27 28 30 42 44 45 50
//- Группа 5: 16 24 36 40
//- Группа 6: 32 48
//Console.Write("Введите N: ");
//int n = int.Parse(Console.ReadLine()!);
static int[][] GroupsNumbersArr(uint number)
{

    /// Если переданное число ноль, то возвращается пустой список групп
    if (number == 0)
        return Array.Empty<int[]>();

    /// Если переданное число единица, то возвращается список групп с одной группой - единицей
    if (number == 1)
        return new int[][] { new int[] { 1 } };

    /// Создание массива для групп
    int[][] groups = new int[(int)Math.Log(number, 2) + 1][];
    groups[0] = new int[] { 1 };
    int indexGroup = 1; // Индекс добавляемой группы

    /// Создание массива чисел содержащего все числа от 1 до заданного
    /// Единица используется как маркер
    /// Вместо удаления элеменов их значение будет приравниваться нулю
    /// После сортировки 1 будет разделять удалённые элементы и оставшиеся
    int[] numbers = new int[number];
    for (int i = 0; i < number; i++)
        numbers[i] = i + 1;

    /// Массив с промежуточными данными
    int[] group = new int[number];

    /// Цикл пока в массиве индекс единицы не последений
    int index1;
    while ((index1 = Array.BinarySearch(numbers, 1)) != number - 1) /// Проверка индекса единицы
    {
        /// Копия элементов в массив группы
        Array.Copy(numbers, group, number);

        int countGroup = 0; /// Количество элементов в группе
                            /// Перебор элементов группы. i - индекс проверяемого элемента
        for (int i = index1 + 1; i < number; i++)
        {
            if (group[i] != 0) /// Пропуск удалённых элементов
            {
                /// Удаление из группы всех элементов кратных проверяемому, кроме его самого
                for (int j = i + 1; j < number; j++)
                    if (group[j] % group[i] == 0)
                        group[j] = 0;

                /// Удаление элемента из массива чисел
                numbers[i] = 0;
                /// Счётчик группы увеличивется
                countGroup++;
            }

        }
        /// Сортировка массивов после удаления элементов
        Array.Sort(group);
        Array.Sort(numbers);

        /// Создание массива для добавления в группы
        /// и копирование в него значений старше 1
        int[] _gr = new int[countGroup];
        Array.Copy(group, Array.BinarySearch(group, 1) + 1, _gr, 0, countGroup);

        /// Добавление группы в массив групп
        groups[indexGroup] = _gr;
        indexGroup++;

    }
    /// Возврат списка групп
    return groups;
}
GroupsNumbersArr(50);
Console.WriteLine("{\r\n" + string.Join("\r\n", GroupsNumbersArr(10).Select(gr => "\t{" + string.Join(", ", gr) + "}")) + "\r\n}");
Console.WriteLine("{\r\n" + string.Join("\r\n", GroupsNumbersArr(17).Select(gr => "\t{" + string.Join(", ", gr) + "}")) + "\r\n}");
Console.WriteLine("{\r\n" + string.Join("\r\n", GroupsNumbersArr(50).Select(gr => "\t{" + string.Join(", ", gr) + "}")) + "\r\n}");